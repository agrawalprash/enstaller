#
# (C) Copyright 2012 Enthought, Inc., Austin, TX
# All right reserved.
#
# This file is open source software distributed according to the terms in
# LICENSE.txt
#

name = 'windows'

is_win = True

bin_dir_name = 'Scripts'

rel_site_packages = ('Lib', 'site-packages')

def remove_file(path):
    """ Remove or unlink a file or directory
    
    The difficulty here is when a file is in use, we can't unlink it on windows.
    Instead we try to move it into a temporary directory.
    
    """
    import os
    if os.path.islink(path):
        os.path.unlink(path)
    elif os.path.isdir(path):
        import shutil
        try:
            shutil.remtree(path)
        except (WindowsError, IOError):
            # directory is in use - move to a temporary directory instead
            import tempfile
            os.rename(path, os.path.join(tempfile.mkdtemp(),
                os.path.basename(path)))
    else:
        try:
            os.unlink(path)
        except (WindowsError, IOError):
            # file is in use - move to a temporary directory instead
            import tempfile
            os.rename(path, os.path.join(tempfile.mkdtemp(),
                os.path.basename(path)))

def install_file(base_path, src, target, executable=None):
    """ Create a link to the src called target
    
    """
    import os
    
    if target == 'PROXY':
        target_dir = os.path.join(base_path, bin_dir_name)
        target_name = src[-1]
        assert target_name.endswith('.exe')
        if target_name.startswith('epd-'):
            target_name = target_name[4:]
        
        target_script_name = target_name[:-4]+'-script.py'
        target_script_path = os.path.join(target_dir, target_script_name)
        if os.path.exists(target_script_path):
            remove_file(target_script_path)
        with open(target_script_name, 'w') as fp:
            fp.write('''\
#!"%(python)s"
# This proxy was created by egginst from an egg with special instructions
#
import sys
import subprocess

src = %(src)r

sys.exit(subprocess.call([src] + sys.argv[1:]))
''' % dict(python=executable, src=os.path.join(base_path, *src)))
        
        
    else:
        if not os.path.isdir(os.path.dirname(target)):
            os.makedirs(os.path.dirname(target))
        if os.path.exists(target):
            remove_file(target)
        
        src_path = os.path.join(base_path, *src)
        with open(src_path, 'rb') as fp:
            data = fp.read()
        with open(target, 'wb') as fp:
            fp.write(data)        
        return [target]

def script_extras(path, name, script_type):
    """ Create appropriate .exe files to wrap a script.
    
    The binary content of these files are read from the module exe_data,
    which may be generated by the following small script (run from the
    setuptools directory which contains the file cli.exe and gui.exe:
    fo = open('exe_data.py', 'w')
    for name in ['cli', 'gui']:
        data = open('%s.exe' % name, 'rb').read()
        fo.write('%s = %r\n' % (name, data))
    fo.close()

    """
    import os
    if script_type == 'console_scripts':
        from exe_data import cli as data
    elif script_type == 'gui_scripts':
        from exe_data import gui as data
    else:
        raise Exception("Did not except script_type=%r" % script_type)
        
    dst = os.path.join(path, name+'.exe')
    if os.path.exists(dst):
        remove_file(dst)
    
    try:
        with open(dst, 'wb') as fp:
            fp.write(data)
            return [dst]
    except IOError:
        # when bootstrapping, egginst.exe will be in use, and so this is expected
        # otherwise its a fairly serious error
        if name != 'egginst':
            raise
    

def get_executable(gui=False):
    """ Return the path to the current Python executable
    
    If gui is True, return the 'pythonw.exe' executable rather than 'python.exe'
    
    """
    import sys
    import os
    executable = sys.executable
    exec_dir = os.path.split(executable)[0]
    if gui:
        return os.path.join(exec_dir, 'pythonw.exe')
    else:
        return os.path.join(exec_dir, 'python.exe')
    
